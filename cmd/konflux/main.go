package main

import (
	"log"
	"strings"

	k "github.com/openshift-pipelines-konflux/hack/internal/konflux"
)

const (
	GithubOrg           = "openshift-pipelines-konflux"
	DefaultImageSuffix  = "-rhel9"
	konfluxDir          = "./.konflux"
	gitHubDir           = ".github"
	tektonDir           = ".tekton"
	autoGeneratedHeader = "# Generated for Konflux Application {{.Name}}-{{.Version.Version}} by hack. DO NOT EDIT"
)

//
//func main1() {
//	dryRun := flag.Bool("dry-run", false, "Dry run (no commit, â€¦)")
//	tmpDir := flag.String("dir", "/tmp/target", "folder to work in. If empty, will create a temporary one")
//	flag.Parse()
//
//	if _, err := exec.LookPath("gh"); !*dryRun && err != nil {
//		log.Fatal("Couldn't find gh in your path, bailing.")
//	}
//	if _, err := exec.LookPath("jq"); !*dryRun && err != nil {
//		log.Fatal("Couldn't find jq in your path, bailing.")
//	}
//
//	configFiles := flag.Args()
//
//	dir := *tmpDir
//	if dir == "" {
//		var err error
//		dir, err = os.MkdirTemp("", "update-konflux-repo")
//		if err != nil {
//			log.Fatal(err)
//		}
//	}
//
//	for _, configFile := range configFiles {
//		in, err := os.ReadFile(configFile)
//		if err != nil {
//			log.Fatal(err)
//		}
//		config := k.Config{}
//		if err := yaml.UnmarshalStrict(in, &config); err != nil {
//			log.Fatal(err)
//		}
//		for _, version := range config.Versions {
//			application := k.Application{
//				Config:  config,
//				Name:    config.Name,
//				Version: &version,
//			}
//			if err := cleanupAutogenerated(context.Background(), application, filepath.Join(konfluxDir, application.Name)); err != nil {
//				log.Fatalln("error while cleaning up  Konflux Dir", err)
//				return
//			}
//
//			if err := generateKonfluxApplication(application); err != nil {
//				log.Fatalln("Error while generating KonFluxApplication", application, err)
//			}
//		}
//
//		for _, resource := range config.Resources {
//			in, err := os.ReadFile(filepath.Join(filepath.Dir(configFile), "repos", resource+".yaml"))
//			if err != nil {
//				log.Fatal(err)
//			}
//			repo := k.Repository{}
//			if err := yaml.UnmarshalStrict(in, &repo); err != nil {
//				log.Fatalf("Error while parsing config %s, Error:  %v ", resource, err)
//			}
//			config.Repos = append(config.Repos, repo)
//		}
//
//		fmt.Printf("Generating konflux configuration for %s\n", config.Name)
//		if err := generateConfig(context.Background(), config, dir, *dryRun); err != nil {
//			log.Fatal(err)
//		}
//
//	}
//}
//
//func generateConfig(ctx context.Context, config k.Config, dir string, dryRun bool) error {
//
//	for _, repo := range config.Repos {
//
//		repository := fmt.Sprintf("https://github.com/%s/%s.git", GithubOrg, repo.Name)
//		repo.Url = repository
//		fmt.Printf("::group:: generating konflux configuration for %s\n", repository)
//
//		//Set Repo Defaults
//		if repo.Tekton.WatchedSources == "" {
//			repo.Tekton.WatchedSources = `"upstream/***".pathChanged() || ".konflux/patches/***".pathChanged() || ".konflux/rpms/***".pathChanged()`
//		}
//
//		// Clone and Checkout main branch for GitHub Workflows
//		checkoutDirMain := filepath.Join(dir, repo.Name+"-main")
//		if err := os.MkdirAll(checkoutDirMain, os.ModePerm); err != nil {
//			return err
//		}
//		if err := k.cloneAndCheckout(ctx, repository, "main", checkoutDirMain, config); err != nil {
//			return err
//		}
//		for _, branch := range repo.Branches {
//			branch.Repository = &repo
//			checkoutDir := filepath.Join(dir, repo.Name+"-"+branch.Name)
//			log.Printf("Generating %s (%s) on %s in %s\n", repo.Name, repository, branch.Name, checkoutDir)
//
//			//Create Checkout Directory
//			if err := os.MkdirAll(checkoutDir, os.ModePerm); err != nil {
//				return err
//			}
//
//			for _, v := range branch.Versions {
//				version := config.Versions[v]
//				if version.Version != v {
//					continue
//				}
//				version.Branch = &branch
//				repo.Application = k.Application{
//					Config:  config,
//					Name:    config.Name,
//					Version: &version,
//				}
//
//				if err := generateKonfluxComponents(version, konfluxDir); err != nil {
//					log.Fatal(err)
//					return err
//				}
//
//				if err := k.cloneAndCheckout(ctx, repository, branch.Name, checkoutDir, config); err != nil {
//					return err
//				}
//				if err := cleanupAutogenerated(ctx, repo.Application, filepath.Join(checkoutDir, tektonDir)); err != nil {
//					return err
//				}
//				//Generate Tekton
//				if err := generateTekton(version, filepath.Join(checkoutDir, tektonDir)); err != nil {
//					log.Fatalln(err)
//				}
//				if repo.Upstream != "" {
//					if err := cleanupAutogenerated(ctx, repo.Application, filepath.Join(checkoutDirMain, gitHubDir)); err != nil {
//						return err
//					}
//					if err := generateGitHubWorkflow(branch, filepath.Join(checkoutDirMain, gitHubDir)); err != nil {
//						log.Fatalln(err)
//					}
//				}
//
//			}
//			if !dryRun && branch.Name != "main" {
//				if err := k.commitAndPullRequest(ctx, checkoutDir, branch.Name, config); err != nil {
//					return err
//				}
//			}
//
//		}
//		if !dryRun {
//			if err := k.commitAndPullRequest(ctx, checkoutDirMain, "main", config); err != nil {
//				return err
//			}
//		}
//	}
//	return nil
//}
//
//func generateTekton(v k.Version, target string) error {
//	log.Printf("Generate tekton manifest in %s\n", target)
//	if err := os.MkdirAll(target, 0o755); err != nil {
//		return err
//	}
//
//	// set defaults
//	branch := v.Branch
//	repo := branch.Repository
//
//	for _, c := range repo.Components {
//		err := updateComponent(&c, v)
//		if err != nil {
//			return err
//		}
//		switch repo.Tekton.EventType {
//		case "pull_request":
//			if err := k.generateFileFromTemplate("component-pull-request.yaml", c, filepath.Join(target, fmt.Sprintf("%s-%s-%s-pull-request.yaml", k.hyphenize(k.basename(repo.Name)), k.hyphenize(v.Version), c.Name)), repo.Application); err != nil {
//				return err
//			}
//		case "push":
//			if err := k.generateFileFromTemplate("component-push.yaml", c, filepath.Join(target, fmt.Sprintf("%s-%s-%s-push.yaml", k.hyphenize(k.basename(repo.Name)), k.hyphenize(v.Version), c.Name)), repo.Application); err != nil {
//				return err
//			}
//		default:
//			if err := k.generateFileFromTemplate("component-pull-request.yaml", c, filepath.Join(target, fmt.Sprintf("%s-%s-%s-pull-request.yaml", k.hyphenize(k.basename(repo.Name)), k.hyphenize(v.Version), c.Name)), repo.Application); err != nil {
//				return err
//			}
//			if err := k.generateFileFromTemplate("component-push.yaml", c, filepath.Join(target, fmt.Sprintf("%s-%s-%s-push.yaml", k.hyphenize(k.basename(repo.Name)), k.hyphenize(v.Version), c.Name)), repo.Application); err != nil {
//				return err
//			}
//		}
//	}
//	return nil
//}

// // This function can be modified  if we want to override the fields at component level.
func UpdateComponent(c *k.Component, repo k.Repository, app k.Application) error {
	log.Printf("Updating component: %s", c.Name)
	version := *app.Version

	c.Version = version
	c.Application = repo.Application
	c.Repository = repo

	if c.Tekton == (k.Tekton{}) {
		c.Tekton = repo.Tekton
	}
	if c.Dockerfile == "" {
		Dockerfile, err := k.Eval(".konflux/dockerfiles/{{.Name}}.Dockerfile", c)
		if err != nil {
			return err
		}
		c.Dockerfile = Dockerfile
	}
	if c.PrefetchInput == "" {
		c.PrefetchInput = "{\"type\": \"rpm\", \"path\": \".konflux/rpms\"}"
	}
	if version.ImageSuffix != "None" {
		c.ImageSuffix = version.ImageSuffix
		if c.ImageSuffix == "" {
			c.ImageSuffix = DefaultImageSuffix
		}
	}
	// This is the case for git-init where we don't require upstream name because comet created is pipelines-git-init-rhel8
	if c.ImagePrefix == "" && !c.NoImagePrefix && repo.Upstream != "" {
		c.ImagePrefix = strings.Split(repo.Upstream, "/")[1] + "-"
		log.Printf("Using image prefix: %s", c.ImagePrefix)
	}
	return nil
}

// func generateKonfluxApplication(application k.Application) error {
// 	konfluxDir := filepath.Join(konfluxDir, k.hyphenize(application.Version.Version), application.Name)
// 	if err := k.generateFileFromTemplate("application.yaml", application, filepath.Join(konfluxDir, "application.yaml"), application); err != nil {
// 		return err
// 	}
// 	if strings.Contains(application.Name, "index") {
// 		if err := k.generateFileFromTemplate("release-tests.yaml", application, filepath.Join(konfluxDir, "release-tests.yaml"), application); err != nil {
// 			return err
// 		}

// 	}
// 	if err := k.generateFileFromTemplate("tests.yaml", application, filepath.Join(konfluxDir, "tests.yaml"), application); err != nil {
// 		return err
// 	}

// 	if application.Version.AutoRelease {
// 		if err := k.generateFileFromTemplate("role.yaml", application, filepath.Join(konfluxDir, "role.yaml"), application); err != nil {
// 			return err
// 		}
// 		if err := k.generateFileFromTemplate("service-account.yaml", application, filepath.Join(konfluxDir, "service-account.yaml"), application); err != nil {
// 			return err
// 		}
// 		if err := k.generateFileFromTemplate("release-plan.yaml", application, filepath.Join(konfluxDir, "release-plan.yaml"), application); err != nil {
// 			return err
// 		}
// 	}
// 	return nil
// }

//func generateKonfluxComponents(version k.Version, targetDir string) error {
//	branch := version.Branch
//	repo := branch.Repository
//	application := repo.Application
//	application.Version = &version
//	konfluxDir := filepath.Join(targetDir, k.hyphenize(application.Version.Version), application.Name)
//
//	log.Printf("Generate %s konflux configuration in %s\n", application.Name, konfluxDir)
//	for _, c := range repo.Components {
//		if err := updateComponent(&c, version); err != nil {
//			return err
//		}
//		if err := k.generateFileFromTemplate("component.yaml", c, filepath.Join(konfluxDir, repo.Name, fmt.Sprintf("component-%s%s.yaml", c.ImagePrefix, c.Name)), application); err != nil {
//			return err
//		}
//		if err := k.generateFileFromTemplate("image.yaml", c, filepath.Join(konfluxDir, repo.Name, fmt.Sprintf("image-%s%s.yaml", c.ImagePrefix, c.Name)), application); err != nil {
//			return err
//		}
//	}
//
//	return nil
//}
//
//func generateGitHubWorkflow(branch k.Branch, target string) error {
//	log.Printf("Generate github manifests in %s\n", target)
//	if err := os.MkdirAll(filepath.Join(target, "workflows"), 0o755); err != nil {
//		return err
//	}
//	filename := fmt.Sprintf("update-sources-%s.yaml", branch.Name)
//	if err := k.generateFileFromTemplate("update-sources.yaml", branch, filepath.Join(target, "workflows", filename), branch.Repository.Application); err != nil {
//		return err
//	}
//	if err := k.generateFileFromTemplate("auto-merge-upstream.yaml", branch, filepath.Join(target, "workflows", fmt.Sprintf("auto-merge-upstream-%s.yaml", branch.Name)), branch.Repository.Application); err != nil {
//		return err
//	}
//	return nil
//}
//
//func cleanupAutogenerated(ctx context.Context, application k.Application, dir string) error {
//	log.Printf("Cleaning up %s\n", dir)
//	header, err := k.eval(autoGeneratedHeader, application)
//	if err != nil {
//		log.Printf("Failed to get autogenerated header: %s\n", err)
//		return nil
//	}
//	if out, err := k.run(ctx, dir, "grep", "-lr", "\""+header+"\""); err != nil {
//		log.Printf("Couldn't grep for autogenerated content: %s, %s", err, out)
//	} else {
//		for _, f := range strings.Split(string(out), "\n") {
//			if f == "" {
//				continue
//			}
//			if err := os.Remove(filepath.Join(dir, f)); err != nil {
//				return fmt.Errorf("couldn't remove autogenerated file %s: %w", f, err)
//			}
//		}
//	}
//	return nil
//}
