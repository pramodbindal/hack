package konflux

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
)

func GenerateConfig(application Application) error {
	if err := generateKonfluxConfig(application); err != nil {
		return err
	}
	if err := generateRepositoryConfig(application); err != nil {
		return err
	}

	return nil
}

func generateRepositoryConfig(application Application) error {
	log.Printf("Generating repository configuration")
	for _, repo := range application.Repositories {
		ctx := context.Background()
		var dir string
		var err error
		if dir, err = cloneAndCheckout(ctx, repo, "/tmp/konflux/"); err != nil {
			return err
		}

		if err := cleanupAutogenerated(ctx, application, dir, tektonDir); err != nil {
			return err
		}
		if err := generateTektonConfig(repo, dir); err != nil {
			return err
		}
		if repo.Upstream != "" {
			if err := cleanupAutogenerated(ctx, application, dir, gitHubDir); err != nil {
				return err
			}
			if err := generateGitHubConfig(repo, dir); err != nil {
				return err
			}
		}

		if err := commitAndPullRequest(ctx, repo, dir); err != nil {
			return err
		}

	}

	return nil

}

func generateTektonConfig(repo Repository, targetDir string) error {
	target := filepath.Join(targetDir, tektonDir)
	log.Printf("Generate tekton config in %s\n", target)

	if err := os.MkdirAll(target, 0o755); err != nil {
		return err
	}

	for _, c := range repo.Components {
		v := c.Version
		if err := generateFileFromTemplate("component-pull-request.yaml", c, filepath.Join(target, fmt.Sprintf("%s-%s-%s-pull-request.yaml", hyphenize(basename(repo.Name)), hyphenize(v.Version), c.Name)), repo.Application); err != nil {
			return err
		}
		if err := generateFileFromTemplate("component-push.yaml", c, filepath.Join(target, fmt.Sprintf("%s-%s-%s-push.yaml", hyphenize(basename(repo.Name)), hyphenize(v.Version), c.Name)), repo.Application); err != nil {
			return err
		}
	}

	return nil
}

func generateGitHubConfig(repo Repository, targetDir string) error {
	target := filepath.Join(targetDir, gitHubDir)
	log.Printf("Generate github manifests in %s\n", target)
	if err := os.MkdirAll(filepath.Join(target, "workflows"), 0o755); err != nil {
		return err
	}

	filename := fmt.Sprintf("auto-merge-upstream-%s.yaml", repo.Name)
	if err := generateFileFromTemplate("auto-merge-upstream.yaml", repo, filepath.Join(target, "workflows", filename), repo.Application); err != nil {
		return err
	}
	filename = fmt.Sprintf("update-sources-%s.yaml", repo.Name)
	if err := generateFileFromTemplate("update-sources.yaml", repo, filepath.Join(target, "workflows", filename), repo.Application); err != nil {
		return err
	}
	_, err := run(context.Background(), ".github", "cp", "renovate.json", target)
	if err != nil {
		return err
	}

	return nil
}

func generateKonfluxConfig(application Application) error {
	targetDir := filepath.Join(konfluxDir, hyphenize(application.Release.Version), application.Name)

	log.Printf("Delete Konflux dir in %s\n", targetDir)
	if err := os.RemoveAll(targetDir); err != nil {
		return err
	}

	if err := generateKonfluxApplication(application, targetDir); err != nil {
		return err
	}

	if err := generateKonfluxComponents(application, targetDir); err != nil {
		return err
	}

	return nil
}

func generateKonfluxApplication(application Application, targetDir string) error {
	if err := generateFileFromTemplate("application.yaml", application, filepath.Join(targetDir, "application.yaml"), application); err != nil {
		return err
	}
	if err := generateFileFromTemplate("tests.yaml", application, filepath.Join(targetDir, "tests.yaml"), application); err != nil {
		return err
	}
	if err := generateFileFromTemplate("service-account.yaml", application, filepath.Join(targetDir, "service-account.yaml"), application); err != nil {
		return err
	}
	if err := generateFileFromTemplate("role.yaml", application, filepath.Join(targetDir, "role.yaml"), application); err != nil {
		return err
	}
	if application.ReleaseToGitHub {
		tempApplication := application
		tempApplication.AutoRelease = false
		if err := generateFileFromTemplate("release-plan.yaml", tempApplication, filepath.Join(targetDir, "release-plan_github.yaml"), tempApplication); err != nil {
			return err
		}
	}
	application.ReleaseToGitHub = false
	if err := generateFileFromTemplate("release-plan.yaml", application, filepath.Join(targetDir, "release-plan.yaml"), application); err != nil {
		return err
	}

	return nil
}

func generateKonfluxComponents(application Application, targetDir string) error {
	log.Printf("Generate %s konflux configuration in %s\n", application.Name, targetDir)
	for _, c := range application.Components {
		componentDir := filepath.Join(targetDir, c.Repository.Name)
		if err := generateFileFromTemplate("component.yaml", c, filepath.Join(componentDir, fmt.Sprintf("component-%s-%s.yaml", c.Name, application.Release.Version)), application); err != nil {
			return err
		}
		if err := generateFileFromTemplate("image.yaml", c, filepath.Join(componentDir, fmt.Sprintf("image-%s-%s.yaml", c.Name, application.Release.Version)), application); err != nil {
			return err
		}
	}

	return nil
}

func cleanupAutogenerated(ctx context.Context, application Application, dir string, subdirs ...string) error {
	cleanupHeader := "# Generated for Konflux Application {{.Name}}"
	for _, subdir := range subdirs {
		log.Printf("Cleaning up %s\n", subdir)
		autoGeneratedHeader, _ := Eval(cleanupHeader, application)
		if out, err := run(ctx, dir, "grep", "-rl", autoGeneratedHeader, subdir); err != nil {
			log.Printf("Couldn't grep for autogenerated content, Error: %v,  Output: %s", err, out)
		} else {
			for _, f := range strings.Split(string(out), "\n") {
				if f == "" {
					continue
				}
				if err := os.Remove(filepath.Join(dir, f)); err != nil {
					return fmt.Errorf("couldn't remove autogenerated file %s: %w", f, err)
				}
			}
		}
	}

	return nil
}
